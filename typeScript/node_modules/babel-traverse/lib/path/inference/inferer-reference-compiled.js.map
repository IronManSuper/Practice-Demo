{"version":3,"sources":["inferer-reference.js"],"names":[],"mappings":"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","file":"inferer-reference-compiled.js","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nexports.default = function (node) {\n  if (!this.isReferenced()) return;\n\n  var binding = this.scope.getBinding(node.name);\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n};\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getTypeAnnotationBindingConstantViolations(path, name) {\n  var binding = path.scope.getBinding(name);\n\n  var types = [];\n  path.typeAnnotation = t.unionTypeAnnotation(types);\n\n  var functionConstantViolations = [];\n  var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n\n  var testType = getConditionalAnnotation(path, name);\n  if (testType) {\n    (function () {\n      var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n\n      constantViolations = constantViolations.filter(function (path) {\n        return testConstantViolations.indexOf(path) < 0;\n      });\n\n      types.push(testType.typeAnnotation);\n    })();\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (var _iterator = constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var violation = _ref;\n\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (types.length) {\n    return t.createUnionTypeAnnotation(types);\n  }\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  var violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(function (violation) {\n    violation = violation.resolve();\n    var status = violation._guessExecutionStatusRelativeTo(path);\n    if (functions && status === \"function\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  var operator = path.node.operator;\n\n  var right = path.get(\"right\").resolve();\n  var left = path.get(\"left\").resolve();\n\n  var target = void 0;\n  if (left.isIdentifier({ name: name })) {\n    target = right;\n  } else if (right.isIdentifier({ name: name })) {\n    target = left;\n  }\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    } else if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    } else {\n      return;\n    }\n  } else {\n    if (operator !== \"===\") return;\n  }\n\n  var typeofPath = void 0;\n  var typePath = void 0;\n  if (left.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = right;\n    typePath = left;\n  }\n  if (!typePath && !typeofPath) return;\n\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n\n  var typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n\n  if (!typeofPath.get(\"argument\").isIdentifier({ name: name })) return;\n\n  return t.createTypeAnnotationBasedOnTypeof(typePath.node.value);\n}\n\nfunction getParentConditionalPath(path) {\n  var parentPath = void 0;\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      } else {\n        return parentPath;\n      }\n    } else {\n      path = parentPath;\n    }\n  }\n}\n\nfunction getConditionalAnnotation(path, name) {\n  var ifStatement = getParentConditionalPath(path);\n  if (!ifStatement) return;\n\n  var test = ifStatement.get(\"test\");\n  var paths = [test];\n  var types = [];\n\n  do {\n    var _path = paths.shift().resolve();\n\n    if (_path.isLogicalExpression()) {\n      paths.push(_path.get(\"left\"));\n      paths.push(_path.get(\"right\"));\n    }\n\n    if (_path.isBinaryExpression()) {\n      var type = inferAnnotationFromBinaryExpression(name, _path);\n      if (type) types.push(type);\n    }\n  } while (paths.length);\n\n  if (types.length) {\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement: ifStatement\n    };\n  } else {\n    return getConditionalAnnotation(ifStatement, name);\n  }\n}\nmodule.exports = exports[\"default\"];"]}