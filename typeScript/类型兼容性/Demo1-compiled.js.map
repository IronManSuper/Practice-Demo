{"version":3,"sources":["Demo1.js"],"names":[],"mappings":";;AAAA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA,IAAI,SAAJ;AACA,CAAC,UAAU,SAAV,EAAqB;AAClB,YAAU,UAAU,OAAV,IAAqB,CAA/B,IAAoC,OAApC;AACA,YAAU,UAAU,UAAV,IAAwB,CAAlC,IAAuC,UAAvC;AACH,CAHD,EAGG,cAAc,YAAY,EAA1B,CAHH;AAIA,SAAS,WAAT,CAAqB,SAArB,EAAgC,MAAhC,EAAwC,CACvC;AACD,YAAY,UAAU,KAAtB,EAA6B,UAAU,CAAV,EAAa;AAAE,SAAO,QAAQ,GAAR,CAAY,EAAE,CAAF,GAAM,GAAN,GAAY,CAAxB,EAA2B,CAA3B,CAAP;AAAuC,CAAnF;AACA,YAAY,UAAU,KAAtB,EAA6B,UAAU,CAAV,EAAa;AAAE,SAAO,QAAQ,GAAR,CAAY,EAAE,CAAF,GAAM,GAAN,GAAY,EAAE,CAA1B,CAAP;AAAsC,CAAlF;AACA,YAAY,UAAU,KAAtB,EAA8B,UAAU,CAAV,EAAa;AAAE,SAAO,QAAQ,GAAR,CAAY,EAAE,CAAF,GAAM,GAAN,GAAY,EAAE,CAA1B,CAAP;AAAsC,CAAnF;AACA;AACA","file":"Demo1-compiled.js","sourcesContent":["/**\r\n * Created by Administrator on 2017/2/8.\r\n */\r\n/**\r\n *类型兼容性\r\n */\r\n//函数参数双向协变\r\n//当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。\r\n//这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候\r\n//却使用了不是那么精确的类型信息。实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式。\r\nvar EventType;\r\n(function (EventType) {\r\n    EventType[EventType[\"Mouse\"] = 0] = \"Mouse\";\r\n    EventType[EventType[\"KeyBoard\"] = 1] = \"KeyBoard\";\r\n})(EventType || (EventType = {}));\r\nfunction listenEvent(eventType, handle) {\r\n}\r\nlistenEvent(EventType.Mouse, function (e) { return console.log(e.x + ',' + e, y); });\r\nlistenEvent(EventType.Mouse, function (e) { return console.log(e.x + ',' + e.y); });\r\nlistenEvent(EventType.Mouse, (function (e) { return console.log(e.x + ',' + e.y); }));\r\n//listenEvent(EventType.Mouse,(e:number)=>console.log(e)); \r\n//# sourceMappingURL=Demo1.js.map"]}